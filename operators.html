<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    
	<link rel="stylesheet" type="text/css" href="./css/bootstrap.min.css?938">
	<link rel="stylesheet" type="text/css" href="style.css?2480">
	<link rel="stylesheet" type="text/css" href="./css/prism.css?2508">
	
	<link rel="stylesheet" type="text/css" href="./css/font-awesome.min.css">
	
    <title>Operators</title>


    
<!-- Analytics -->
 
<!-- Analytics END -->
    
</head>
<body>

<!-- Preloader -->
<div id="page-loading-blocs-notifaction" class="page-preloader"></div>
<!-- Preloader END -->


<!-- Main container -->
<div class="page-container">
    
<!-- bloc-0 -->
<div class="bloc l-bloc" id="bloc-0">
	<div class="container bloc-sm">
		<div class="row">
			<div class="col">
				<nav class="navbar navbar-light row navbar-expand-md" role="navigation">
					<a class="navbar-brand" href="index.html">WindFlow</a>
					<button id="nav-toggle" type="button" class="ml-auto ui-navbar-toggler navbar-toggler border-0 p-0" data-toggle="collapse" data-target=".navbar-48557" aria-expanded="false" aria-label="Toggle navigation">
						<span class="navbar-toggler-icon"></span>
					</button>
					<div class="collapse navbar-collapse navbar-48557">
						<ul class="site-navigation nav navbar-nav ml-auto">
							<li class="nav-item">
								<a href="index.html" class="btn btn-lg btn-glossy btn-azure">Home</a>
							</li>
							<li>
								<a href="operators.html" class="btn btn-lg btn-glossy btn-azure">Operators</a>
							</li>
							<li>
								<a href="usage.html" class="btn btn-lg btn-glossy btn-azure">API<br></a>
							</li>
							<li>
								<a href="usage_gpu.html" class="btn btn-lg btn-glossy btn-azure">API GPU</a>
							</li>
							<li>
								<a href="kafka.html" class="btn btn-lg btn-glossy btn-azure">API Kafka<br></a>
							</li>
							<li>
								<a href="rocksdb.html" class="btn btn-lg btn-glossy btn-azure">API RocksDB<br></a>
							</li>
							<li>
								<a href="dashboard.html" class="btn btn-lg btn-glossy btn-azure">Dashboard</a>
							</li>
							<li>
								<a href="https://github.com/ParaGroup/WindFlow/archive/refs/tags/v4.0.0.zip" class="btn btn-lg btn-glossy btn-azure">Download</a>
							</li>
							<li>
								<a href="about.html" class="btn btn-lg btn-glossy btn-azure">About</a>
							</li>
						</ul>
					</div>
				</nav>
			</div>
		</div>
	</div>
</div>
<!-- bloc-0 END -->

<!-- bloc-1 -->
<div class="bloc none l-bloc" id="bloc-1">
	<div class="container ">
		<div class="row bgc-azure">
			<div class="order-md-0 col-md-12 col-lg-6 order-lg-1 offset-lg-1">
				<img src="img/logo_white.png" class="img-fluid img-style float-lg-none" alt="logo_white" />
			</div>
			<div class="align-self-center offset-md-1 col-md-10 col-lg-4 col-sm-10 offset-sm-1 col-10 offset-1">
				<h4 class="mg-md tc-white btn-resize-mode h2-style float-lg-right">
					A C++17 Data Stream Processing Parallel Library for Multicores and GPUs&nbsp;<br>
				</h4>
			</div>
		</div>
	</div>
</div>
<!-- bloc-1 END -->

<!-- bloc-3 -->
<div class="bloc tc-davys-grey-3 l-bloc" id="bloc-3">
	<div class="container bloc-lg">
		<div class="row">
			<div class="col">
				<h2 class="mg-md tc-davys-grey-2">
					<strong>Operators</strong>
				</h2>
				<p class="text-justify">
					WindFlow provides a quite rich set of operators like popular streaming frameworks (e.g, Apache Flink). The figure below shows the list of operators and a brief description of each of them.
				</p><img src="img/lazyload-ph.png" data-src="img/operators_list.jpg" class="img-fluid mx-auto d-block img-operato-style mg-md lazyload" alt="Operator suite of WindFlow" />
				<h2 class="mg-md tc-davys-grey-2 tc-davys-grey">
					<strong>Operator Parallelism</strong>
				</h2>
				<p class="text-justify">
					Sources, the other <strong>basic operators</strong>, and sinks have an immediately clear semantics for programmers a bit expert with open-source stream processing frameworks. During their instantiation, the programmer can specify a <strong>parallelism level</strong> (number of replicas). Each replica receives a fraction of the input stream in order to process inputs in parallel to improve throughput. The Map, Filter, FlatMap and Sink operators can be configured to work on a <strong>keyby basis</strong>, i.e., all the inputs with the same key attribute are delivered to the same destination replica by the preceding operator. The Reduce operator always works on a keyby basis.<br><br>In addition, the library provides a set of <strong>window-based operators</strong> that offer a useful set of programming abstractions [1,2] to express different kinds of parallelism approaches solving window-based streaming analytics tasks:<br>
				</p>
				<div >
					<ul>
<li><b>Key-based parallelism</b>: it is the default parallelism exploitation pattern in stream processing systems dealing with stateful computations. The assumption is that the stream conveys input items belonging to multiple logical substreams, each composed of items all having the same value of a <i>key attribute</i> (a.k.a. keyed streams). The idea is to execute in parallel the processing of sliding windows belonging to different substreams. The default operator enabling this behavior is the <b>Keyed_Windows</b> (KW).</li>
<li><b>Inter-window parallelism</b>: in case of high-speed streams, sliding windows can become ready to be computed very frequently. The idea is to split the set of windows to compute among different parallel entities in charge of doing the processing in parallel on distinct windows (regardless the fact that they belong to different or to the same keyed substream). The operators enabling this behavior are the <b>Parallel_Windows</b> (PW) and the <b>Paned_Windows</b> (PaW).</li>
<li><b>Intra-window parallelism</b>: the idea is to go in parallel within the computation of each window, by splitting its content in partitions that are processed in parallel while the results of the partitions are computed and merged to obtain window-wise results. The operators enabling this behavior are the <b>Paned_Windows</b> (PaW) and the <b>MapReduce_Windows</b> (MRW).</li>
</ul>
					
				</div>
				<p class="text-justify">
						The idea of these approaches&nbsp;is sketched in the figure below. For simplicity, we show an example with <strong>count-based windows</strong> of length of six items sliding every two items. However, the library also provides support to <strong>time-based windows</strong> (with event time semantics only at the moment) instantiated with both non-incremental and incremental queries.
					</p><img src="img/lazyload-ph.png" data-src="img/windows.jpg" class="img-fluid mx-auto d-block img-windo-style mg-md lazyload" alt="Parallelism exploitation patterns on sliding windows" />
				<p class="text-justify">
						Intra-window parallelism needs additional explanations. The library supports operators enabling the parallel processing within each window. The first is based on the <strong>paned approach</strong> [3], where each window is split into tumbling windows called <i>panes</i> with length equal to the greatest common divisor<i>&nbsp;</i>between the window length and its slide (in the example, each pane is two items long). The operator computes a partial result per pane (by processing them in parallel if possible), and the pane results are eventually aggregated to produce window-wise results (in the example three pane results are needed per window). A good point in favor of this approach is that pane results shared by consecutive windows do not need to be recomputed by improving the computation performance.<br><br>The second approach to intra-window parallelism is based on the <strong>map-reduce pattern</strong>: each window is split into partitions, and a partial result is computed per partition. Then, partition results are aggregated into window-wise results. Although similar to the paned approach, here the size of the partitions depends on the number of parallel replicas involved in the processing of the operator (two in the figure below, right-hand side), leading to the possibility to decrease the processing latency proportionally to the parallelism level used by the operator. However, differently from the paned approach, windows are recomputed from scratch although in parallel.<br>
					</p><img src="img/lazyload-ph.png" data-src="img/windows-2.jpg" class="img-fluid mx-auto d-block img-windows-style mg-md lazyload" alt="Intra-window parallelism" />
				<p class="text-justify">
						We point out that the existing frameworks do not provide all these parallel operators in an integrated and easy-to-use manner. As an example, Apache Storm and Apache Flink provide key-based parallelism natively, while intra-window parallelism is naturally provided in Spark Streaming as a derivation from the Spark engine for batch processing and map-reduce computations.<br><br>Starting from version 2.8 of the library, WindFlow provides a further window-based operator called <strong>FFAT_Windows</strong>. As for the Keyed_Windows operator, this operator processes windows of different keyed substreams in parallel on different cores of the CPU. However, windows of the same substream are processed using the Flat Fixed-size Aggregator approach (Flat-FAT) based on balanced binary trees. The approach avoids recomputing windows from scratch. Further details can be found in the paper presenting this approach for the first time [4].<br>
					</p>
				<h2 class="mg-md tc-davys-grey-2 tc-davys-grey">
						<strong>GPU Operators</strong>
					</h2>
				<p class="text-justify">
						WindFlow version 3.x supports operators targeting NVIDIA GPU devices. The idea is that the processing of hotspot computationally intensive operators can be accelerated leveraging GPU devices and small <strong>batching approaches</strong>. A GPU operator receives a batch of inputs from the preceding operators in the dataflow graph and processes each batch in parallel on GPU.<br><br>For <strong>stateless operators</strong>, i.e., the one created without a keyby modifier, all inputs within the batch are processed in parallel on GPU by a CUDA thread each. This idea is shown in the figure below.<br>
					</p><img src="img/lazyload-ph.png" data-src="img/gpu_stateless.jpg" class="img-fluid mx-auto d-block img-gpu-statele-style mg-md lazyload" alt="GPU stateless processing" />
				<p class="text-justify">
						<strong>Stateful operators</strong> require a keyby distribution and maintain a state partition per key. The general requirement is that all inputs belonging to the same substream are processed sequentially by reading and modifying the associated state. WindFlow provides a clever approach to do that on GPU, by keeping a device object per key representing the state partition, and enforcing the stateful constraints in the design of the internal CUDA kernels.<br>
					</p><img src="img/lazyload-ph.png" data-src="img/gpu_stateful.jpg" class="img-fluid mx-auto d-block img-gpu-statef-style mg-md lazyload" alt="GPU stateful processing" />
				<p>
						From the release 3.0.0, WindFlow supports both&nbsp;<strong>Map</strong> and&nbsp;<strong>Filter</strong> operators on GPU. Furthermore, a GPU variant of the FFAT_Windows has also been provided (<strong>FFAT_Windows_GPU</strong>), which uses a modified version of the FlatFAT structure that can efficiently be computed on GPU.
					</p>
				<h2 class="mg-md h3-color tc-davys-grey">
						<strong>References</strong>
					</h2>
				<p>
						Useful references for this page:
					</p>
				<div >
						<ol>
<li> G. Mencagli, M. Torquati, D. Griebler, M. Danelutto and L. G. L. Fernandes. Raising the Parallel Abstraction Level for Streaming Analytics Applications. IEEE Access, vol. 7, pp. 131944-131961, 2019. DOI: 10.1109/ACCESS.2019.2941183
</li><li>Tiziano Matteis and Gabriele Mencagli. 2017. Parallel Patterns for Window-Based Stateful Operators on Data Streams: An Algorithmic Skeleton Approach. Int. J. Parallel Program. 45, 2 (April 2017), 382-401. DOI: https://doi.org/10.1007/s10766-016-0413-x</li>
<li>Jin Li, David Maier, Kristin Tufte, Vassilis Papadimos, and Peter A. Tucker. 2005. No pane, no gain: efficient evaluation of sliding-window aggregates over data streams. SIGMOD Rec. 34, 1 (March 2005), 39-44. DOI: http://dx.doi.org/10.1145/1058150.1058158</li>
<li>Kanat Tangwongsan, Martin Hirzel, Scott Schneider, and Kun-Lung Wu. 2015. General incremental sliding-window aggregation. Proc. VLDB Endow. 8, 7 (February 2015), 702–713. DOI:https://doi.org/10.14778/2752939.2752940</li>
<li>T. De Matteis, G. Mencagli, D. De Sensi, M. Torquati and M. Danelutto. GASSER: An Auto-Tunable System for General Sliding-Window Streaming Operators on GPUs. IEEE Access, vol. 7, pp. 48753-48769, 2019. DOI: 10.1109/ACCESS.2019.2910312</li>
</ol>
						
					</div>
			</div>
		</div>
	</div>
</div>
<!-- bloc-3 END -->

<!-- ScrollToTop Button -->
<a class="bloc-button btn btn-d scrollToTop" onclick="scrollToTarget('1',this)"><span class="fa fa-chevron-up"></span></a>
<!-- ScrollToTop Button END-->


<!-- bloc-8 -->
<div class="bloc l-bloc" id="bloc-8">
	<div class="container bloc-lg">
		<div class="row">
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					About
				</h4><a href="http://calvados.di.unipi.it/paragroup/" class="a-btn a-block footer-link ltc-azure">PPMs Group</a><a href="https://www.unipi.it/" class="a-btn a-block footer-link ltc-azure">University of Pisa</a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					<br>
				</h4><a href="index.html" class="a-btn a-block footer-link"></a><a href="index.html" class="a-btn a-block footer-link"><br></a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					<br>
				</h4><a href="index.html" class="a-btn a-block footer-link"><br></a><a href="index.html" class="a-btn a-block footer-link"></a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					Get the library
				</h4><a href="https://github.com/ParaGroup/WindFlow/archive/refs/tags/3.6.0.zip" class="a-btn a-block footer-link ltc-azure">Download</a><a href="https://github.com/ParaGroup/WindFlow" class="a-btn a-block footer-link ltc-azure">GitHub</a>
			</div>
		</div>
	</div>
</div>
<!-- bloc-8 END -->

</div>
<!-- Main container END -->
    

<!-- Additional JS -->
<script src="./js/jquery-3.5.1.min.js?7885"></script>
<script src="./js/bootstrap.bundle.min.js?7420"></script>
<script src="./js/blocs.min.js?2652"></script>
<script src="./js/lazysizes.min.js" defer></script>
<script src="./js/prism.js?3031"></script>
<!-- Additional JS END -->


</body>
</html>
