<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="WindFlow Home Page">
  <meta name="author" content="Gabriele Mencagli">
  <title>WindFlow</title>
  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles for this template -->
  <link href="css/scrolling-nav.css" rel="stylesheet">
  <link href="css/prism.css" rel="stylesheet" />
</head>

<body id="page-top">
  <script src="js/prism.js"></script>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">WindFlow</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="index.html">Overview</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#Operators">Operators</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="usage.html">Usage</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="dashboard.html">Dashboard</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="performance.html">Performance</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="https://github.com/ParaGroup/WindFlow.git">Download</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="credits.html">Credits</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <header class="bg-primary text-white">
    <div class="container text-center">
      <!--<h1>WindFlow</h1>-->
      <img src="logo/logo_white.png" alt="WindFlow" height="180">
      <p class="lead">A C++17 Data Stream Processing Parallel Library for Multicores and GPUs</p>
    </div>
  </header>

  <section id="Operators">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h1>Operators</h1>
          <p class="lead"><code>WindFlow</code> provides a quite rich set of operators, as in traditional streaming frameworks. The figure below shows the list of operators and a brief description of each of them.</p>
          <p class="lead"><div class="oversizedImage"><img src="imgs/operators.jpg" width="160%" align="middle"/></div></p>
          <br>
          <h2>Operator Parallelism</h2>
          <p class="lead"> Sources, the other basic operators and sinks have an immediately clear semantics for programmers a bit expert in open-source stream processing frameworks. During their instantiation, the programmer can specify a <b>parallelism level</b> (number of replicas, each executed by a dedicated thread). Each replica receives a fraction of the input stream in order to process inputs in parallel and improve throughput. If not specified, the inputs are evenly distributed to the internal replicas of the operator. The Map, Filter, FlatMap and Sink operators can be alternatively configured to work in a <b>keyby</b> basis, i.e. all the inputs with the same key attribute are delivered to the same replica. The Accumulator operator always works in a keyby basis.</p>
          <p class="lead"> In addition, the library provides a set of windowed operators that offer a unique set of programming abstractions [1,2] to express different kinds of parallelism addressing window-based streaming analytics tasks:</p>
          <ul>
            <li><b>Key-based parallelism</b>: it is the default parallelism exploitation pattern in stream processing systems dealing with stateful computations. The assumption is that the stream conveys input items belonging to multiple logical substreams composed of items having the same value of a <i>key attribute</i> (a.k.a. <b>keyed streams</b>). The idea is to execute in parallel the processing of sliding windows belonging to different substreams. The operator enabling this behavior is the <b>Key_Farm</b> (KF) one;</li>
            <li><b>Inter-Window parallelism</b>: in case of high-speed streams and computationally demanding tasks, sliding windows can become ready to be computed very fastly. The idea is to split the set of windows to compute among different parallel entities in charge of doing the processing in parallel on distinct windows (regardless the fact that they belong to different or to the same substream). The operators enabling this behavior are the <b>Win_Farm</b> (WF) and the <b> Pane_Farm</b> (PF) ones;</li>
            <li><b>Intra-Window parallelism</b>: the idea is to go in parallel within the computation of each window, by splitting its content in partitions that are processed in parallel while the results of the partitions are computed and merged to obtain window-wise results. The operators enabling this behavior are the <b>Pane_Farm</b> (PF) and the <b>Win_MapReduce</b> (WMR) ones.</li>
          </ul>
          <p class="lead">The idea of these parallelism dimensions is sketched in the figure below. For simplicity, we show an example with <code>count-based windows</code> of length of <code>6</code> items sliding every <code>2</code> items. However, the library also provides support to <code>time-based windows</code> (with event time semantics) instantiated with both <code>non-incremental</code> and <code>incremental</code> queries.</p>
          <p style="text-align:center;"><img src="imgs/windows.jpg" width="100%" align="middle"/></p>
          <p class="lead">Intra-window parallelism needs additional explanations. The library supports operators enabling the parallel processing within each window. The first is based on the well-known <code>paned approach</code> [3], where each window is split into tumbling windows called <i>panes</i> with length equal to the GDC between the window length and its slide (in the example, each pane is two items long). The operator computes a partial result per pane (by processing them in parallel if possible), and the panes are aggregated together to produce window results (in the example three pane results are needed per window). A good point of this approach is that pane results shared by consecutive windows do not need to be recomputed by improving the computation performance.</p>
          <p class="lead">The second approach to intra-window parallelism is based on the <code>map-reduce</code> idea: each window is split into partitions, and a partial result is computed per partition. Then, partition results are aggregated into window-wise results. Although similar to the paned approach, here the size of the partitions depends on the number of parallel replicas involved in the processing of the operator (two in the figure below, right-hand side), leading to the possibility to decrease the processing latency proportionally to the replication degree used by the operator. However, differently from the paned approach, windows are recomputed from scratch although in parallel.</p>
          <p style="text-align:center;"><img src="imgs/windows-2.jpg" width="100%" align="middle"/></p>
          <p class="lead">We point out that the existing frameworks fail to provide all these parallelism dimensions in an integrated and easy to use manner. As an example, Apache Storm and Apache Flink provide natively key-based parallelism, while intra-window parallelism is naturally provided in Spark Streaming as a derivation from the Spark engine for batch processing and map-reduce computations.</p>
          <p class="lead">Starting from version 2.8 of the library, <code>WindFlow</code> provides a further window-based operator called <b>Key_FFAT</b>. As the Key_Farm operator, the Key_FFAT processes windows of different keyed streams in parallel on different cores of the CPU. However, windows of the same substream are processed using the <b>Flat Fixed-size Aggregator</b> (Flat-FAT) based on balanced binary trees. The approach avoids recomputing windows from scratch. Further details can be found in the paper presenting the approach for the first time [4].</p>
          <h2>Exploitation of GPU Devices</h2>
          <p class="lead">Window-based operators have also a GPU implementation in the library (the approach has been described in [5]). The idea is to batch a set of input items corresponding to the data needed to process <i>B>0</i> consecutive windows of the same substream, where <i>B</i> is a configurable parameter chosen by the user. The library, using <code>CUDA</code> (>=v10), offloads the processing of each batch on the device where all the windows within a batch are processed in parallel by distinct <code>CUDA</code> threads. This idea is depicted in the figure below.</p>
          <p style="text-align:center;"><img src="imgs/windows-gpu.jpg" width="100%" align="middle"/></p>
          <p class="lead">This approach is applied to all the windowed operators in the library providing a GPU variant for each of them. While in the Key_Farm and Win_Farm operator each <code>CUDA</code> thread is in charge of processing an entire window within a batch, in the Pane_Farm and Win_MapReduce operators the programmer can choose which of the two phases of the computation are going to be offloaded on the GPU:</p>
          <ul>
            <li>in the Pane_Farm operator, either the <b>PLQ</b> stage (Pane-level Sub-Query), producing a result per pane, or the <b>WLQ</b> (Window-level Sub-Query) aggregating pane results into window results can be offloaded on the device while the other one is run (in parallel) on the CPU cores;</li>
            <li> in the Win_MapReduce operator, either the <b>MAP</b> stage (processing partitions) or the <b>REDUCE</b> phase (merging partition results) can be executed on the device while the other one is run on the CPU cores.</li>
          </ul>
          <p class="lead">The <b>Key_FFAT_GPU</b> operator adapts the Flat-FAT aggregator to work on a batched basis, where the tree struture is used to efficiently compute the results of all the windows within the same batch. Further details about this idea will be published in a research paper soon.</p>
          <h2>References</h2>
          <ol>
            <li> G. Mencagli, M. Torquati, D. Griebler, M. Danelutto and L. G. L. Fernandes. Raising the Parallel Abstraction Level for Streaming Analytics Applications. IEEE Access, vol. 7, pp. 131944-131961, 2019. DOI: 10.1109/ACCESS.2019.2941183
            <li>Tiziano Matteis and Gabriele Mencagli. 2017. Parallel Patterns for Window-Based Stateful Operators on Data Streams: An Algorithmic Skeleton Approach. Int. J. Parallel Program. 45, 2 (April 2017), 382-401. DOI: https://doi.org/10.1007/s10766-016-0413-x</li>
            <li>Jin Li, David Maier, Kristin Tufte, Vassilis Papadimos, and Peter A. Tucker. 2005. No pane, no gain: efficient evaluation of sliding-window aggregates over data streams. SIGMOD Rec. 34, 1 (March 2005), 39-44. DOI: http://dx.doi.org/10.1145/1058150.1058158</li>
            <li>Kanat Tangwongsan, Martin Hirzel, Scott Schneider, and Kun-Lung Wu. 2015. General incremental sliding-window aggregation. Proc. VLDB Endow. 8, 7 (February 2015), 702â€“713. DOI:https://doi.org/10.14778/2752939.2752940</li>
            <li>T. De Matteis, G. Mencagli, D. De Sensi, M. Torquati and M. Danelutto. GASSER: An Auto-Tunable System for General Sliding-Window Streaming Operators on GPUs. IEEE Access, vol. 7, pp. 48753-48769, 2019. DOI: 10.1109/ACCESS.2019.2910312</li>
          </ol>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; WindFlow (LGPL-3.0)</p>
    </div>
    <!-- /.container -->
  </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>
  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>
</body>

</html>