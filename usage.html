<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="keywords" content="">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    
	<link rel="stylesheet" type="text/css" href="./css/bootstrap.min.css?1964">
	<link rel="stylesheet" type="text/css" href="style.css?8547">
	<link rel="stylesheet" type="text/css" href="./css/prism.css?4892">
	
	<link rel="stylesheet" type="text/css" href="./css/font-awesome.min.css">
	
    <title>Usage</title>

<head>
  <link href="prism.css" rel="stylesheet" />
</head>
    
<!-- Analytics -->
 
<!-- Analytics END -->
    
</head>
<body>

<!-- Preloader -->
<div id="page-loading-blocs-notifaction" class="page-preloader"></div>
<!-- Preloader END -->


<!-- Main container -->
<div class="page-container">
    
<!-- bloc-0 -->
<div class="bloc l-bloc" id="bloc-0">
	<div class="container bloc-sm">
		<div class="row">
			<div class="col">
				<nav class="navbar navbar-light row navbar-expand-md" role="navigation">
					<a class="navbar-brand" href="index.html">WindFlow</a>
					<button id="nav-toggle" type="button" class="ml-auto ui-navbar-toggler navbar-toggler border-0 p-0" data-toggle="collapse" data-target=".navbar-48557" aria-expanded="false" aria-label="Toggle navigation">
						<span class="navbar-toggler-icon"></span>
					</button>
					<div class="collapse navbar-collapse navbar-48557">
						<ul class="site-navigation nav navbar-nav ml-auto">
							<li class="nav-item">
								<a href="index.html" class="btn btn-lg btn-glossy btn-azure">Home</a>
							</li>
							<li>
								<a href="operators.html" class="btn btn-lg btn-glossy btn-azure">Operators</a>
							</li>
							<li>
								<a href="usage.html" class="btn btn-lg btn-glossy btn-azure">API<br></a>
							</li>
							<li>
								<a href="usage_gpu.html" class="btn btn-lg btn-glossy btn-azure">API GPU</a>
							</li>
							<li>
								<a href="special.html" class="btn btn-lg btn-glossy btn-azure">API Kafka<br></a>
							</li>
							<li>
								<a href="dashboard.html" class="btn btn-lg btn-glossy btn-azure">Dashboard</a>
							</li>
							<li>
								<a href="https://github.com/ParaGroup/WindFlow/archive/refs/tags/3.4.0.zip" class="btn btn-lg btn-glossy btn-azure">Download</a>
							</li>
							<li>
								<a href="about.html" class="btn btn-lg btn-glossy btn-azure">About</a>
							</li>
						</ul>
					</div>
				</nav>
			</div>
		</div>
	</div>
</div>
<!-- bloc-0 END -->

<!-- bloc-1 -->
<div class="bloc none l-bloc" id="bloc-1">
	<div class="container ">
		<div class="row bgc-azure">
			<div class="order-md-0 col-md-12 col-lg-6 order-lg-1 offset-lg-1">
				<img src="img/logo_white.png" class="img-fluid img-style float-lg-none" alt="logo_white" />
			</div>
			<div class="align-self-center offset-md-1 col-md-10 col-lg-4 col-sm-10 offset-sm-1 col-10 offset-1">
				<h4 class="mg-md tc-white btn-resize-mode h2-style float-lg-right">
					A C++17 Data Stream Processing Parallel Library for Multicores and GPUs&nbsp;<br>
				</h4>
			</div>
		</div>
	</div>
</div>
<!-- bloc-1 END -->

<!-- bloc-4 -->
<div class="bloc tc-davys-grey l-bloc" id="bloc-4">
	<div class="container bloc-lg">
		<div class="row">
			<div class="col">
				<h2 class="mg-md tc-davys-grey-2">
					<strong>API Example</strong><br>
				</h2>
				<div >
				</div>
				<div >
						<script src="js/prism.js"></script>
						
					</div>
				<p class="text-justify">
							In this page, we show a simple example of streaming application in WindFlow. The example is a well-known streaming benchmark:&nbsp;<strong>WordCount</strong>. The Source operator is in charge of generating a stream of text lines. The second operator (Splitter) receives the text lines and splits them into words transmitted to the next operator (Counter). The Counter updates the count of each distinct received word, and sends a pair (word, count) to the Sink with the current value of the counter. While Splitter and Sink are stateless, the Counter is a stateful operator working on a keyby manner. The figure below shows a schematic view of the logical data-flow graph of the application.<br>
						</p><img src="img/lazyload-ph.png" data-src="img/application.jpg" class="img-fluid mx-auto d-block img-applicati-style mg-md lazyload" alt="WordCount logical data-flow graph" />
				<p class="text-justify">
							We report below some code snippets to understand the API. The Source can be defined by developing its functional logic through a functor, a lambda, or using a C++ function. In all cases, the logic must respect specific admissible signatures to be used to instantiate a Source operator. In the snippet below the source logic is developed as a C++ functor.
						</p>
				<div >
							<pre><code class="language-cpp">
class Source_Functor
{
private:
	std::vector&lt;std::string> dataset; // contains the text lines as strings

public:
	// Constructor
    Source_Functor(const std::vector&lt;std::string> &amp;_dataset):
                   dataset(_dataset) {}

	// Functor logic
	void operator()(wf::Source_Shipper&lt;std::string> &amp;shipper)
	{
    	// generation loop
    	for (auto &amp;line: dataset) {
    		shipper.push(line);
    	}
	}
};
</code></pre>
							
						</div>
				<p class="text-justify">
								The Splitter is implemented as a FlatMap operator producing more outputs per input. Again, the functional logic can be provided as a function, lambda or a functor object (as in the snippet below) respecting a specific signature.<br>
							</p>
				<div >
								<pre><code class="language-cpp">
class Splitter_Functor
{
public:
	// Functor logic
    void operator()(const std::string &amp;input, wf::Shipper&lt;std::string> &amp;shipper)
    {
        std::istringstream line(input);
        std::string word;
        while (getline(input, word, ' ')) {
            shipper.push(std::move(word));
        }
    }
};
</code></pre>
								
							</div>
				<p>
									The Counter can be implemented by a Map operator encapsulating an internal state partitioned by key (a hash table).
								</p>
				<div >
									<pre><code class="language-cpp">
class Counter_Functor
{
private:
	std::unordered_map&lt;std::string, int> table;

public:
	// Functional logic
    std::pair&lt;std::string, int> operator()(const std::string &amp;word)
    {
		if (map.find(word) == map.end()) {
        	map.insert(make_pair(word, 1));
		}
        else {
            map.at(word)++;
        }
        std::pair result(word, map.at(word));
        return result;
    }
};
</code></pre>
									
								</div>
				<p>
										Finally, we define the Sink functional logic as below.
									</p>
				<div >
										<pre><code class="language-cpp">
class Sink_Functor
{
public:
	// Functor logic
    void operator()(std::optional&lt;std::pair&lt;std::string, int>> &amp;input)
    {
        if (input) {
            std::cout &lt;&lt; "Received word " &lt;&lt; (*input).first &lt;&lt; " with counter " &lt;&lt; (*input).second &lt;&lt; std::endl;
        }
        else {
        	std::cout &lt;&lt; "End of stream" &lt;&lt; std::endl;
        }
    }
};
</code></pre>
										
									</div>
				<p class="text-justify">
											Once defined the functional logic of each operator, they must be created by using the corresponding <strong>builder</strong> classes. During the creation, the user can specify several configuration parameters per operator, like its name (for logging purposes), its parallelism level and others.
										</p>
				<div >
											<pre><code class="language-cpp">
Source_Functor source_functor(dataset);
wf::Source source = wf::Source_Builder(source_functor)
                		.withParallelism(2)
                		.withName("wc_source")
                		.build();

Splitter_Functor splitter_functor;
wf::FlatMap splitter = wf::FlatMap_Builder(splitter_functor)
                	   		.withParallelism(2)
                			.withName("wc_splitter")
                			.withOutputBatchSize(10)
                			.build();

Counter_Functor counter_functor;
wf::Map counter = wf::Map_Builder(counter_functor)
              	  		.withParallelism(3)
                		.withName("wc_counter")
                		.withKeyBy([](const std::string &amp;word) -> std::string { return word; })
                		.build();

Sink_Functor sink_functor;
wf::Sink sink = wf::Sink_Builder(sink_functor)
                	.withParallelism(3)
                	.withName("wc_sink")
                	.build();
</code></pre>
											
										</div>
				<p class="text-justify">
												All the operators (except Sinks) can be declared with a custom&nbsp;<strong>output batch size</strong>. In the example above, the Splitter operator adopts a batching of 10 outputs, which means that it sends output results in batches of 10 individual outputs. This approach can be used to increase throughput at the expense of latency. If not specified, the batch size is zero (means that batching is disabled) and the operators send outputs individually. Furthermore, we observe that the Counter operator is declared with a <strong>key extractor</strong> to enable the keyby distribution between the Splitter and the Counter replicas.<br><br>Finally, the whole application can be executed by creating the streaming environment and by adding the operators in the proper order. This can be done by leveraging two programming constructs of WindFlow: the <strong>PipeGraph</strong> and the <strong>MultiPipe</strong> classes. The PipeGraph can be instantiated by specifying two configuration options: the <strong>execution mode</strong> and the <strong>time policy</strong>.<br><br>The execution mode states how the processing is done in the data-flow graph with respect to the ordering of inputs. There are three alternative modes:<br>
											</p>
				<div >
												<ol>
<li><b>DETERMINISTIC</b>: in this mode the user is requested to generate inputs in the Sources ordered by timestamps. The run-time environment guarantees that the replicas of all operators will process inputs ordered by timestamp. This execution modes prevents batching to be used and allows a deterministic execution often at the expense of performance.</li>
<li><b>PROBABILISTIC</b>: in this mode Source replicas can generate outputs in any order, but the run-time system still sorts items before processing the functional logics of the operators. In this case, to respect the ordering, items might be dropped. This execution mode still prevents batching to be used, but can be a reasonable compromise between ordering requirements and performance if some (few) dropped inputs are allowed by the application semantics.</li>
<li><b>DEFAULT</b>: this is the default mode without ordering guarantees. In this mode, inputs are processed in a non-deterministic ordering and temporal window-based computations are evaluated based on <b>watermarks</b> propagation. This execution mode allows batching to be used in the operators as in the previous code snippets.</li>
</ol>
												
											</div>
				<p class="text-justify">
													For what regards the time policy, WindFlow supports two policies. With "<strong>Ingress Time</strong>", timestamps are automatically generated by the Sources (as in this WordCount example in the Source functor object) and watermarks are also automatically generated incase of DEFAULT execution mode. With “<strong>Event Time</strong>”, the user is instead in charge of emitting inputs in the sources with a user-defined timestamp. With this policy, watermarks must explicitly be emitted by the user in the sources in case of DEFAULT execution mode.<br><br>The code fragment below shows the creation of the PipeGraph and of the data-flow graph which is then run on a multi-core environment.
												</p>
				<div >
													<pre><code class="language-cpp">
wf::PipeGraph topology("wc", Execution_Mode_t::DEFAULT, Time_Policy_t::INGRESS_TIME);
if (chaining) {
	topology.add_source(source).chain(splitter).add(counter).chain_sink(sink);
}
else {
	topology.add_source(source).add(splitter).add(counter).add_sink(sink);
}
topology.run(); // synchronous execution of the dataflow
</code></pre>
													
												</div>
				<p class="text-justify">
														In the code above, based on the value of a boolean flag (<strong>chaining</strong>), we create the data-flow graph by chaining stateless operators (to reduce thread oversubscription) or not. This results in two different physical data-flow graphs running respectively with five (left-hand side figure below) and ten (right-hand side) underlying threads (based on the chosen parallelism levels in the builders).
													</p><img src="img/lazyload-ph.png" data-src="img/application_physical.jpg" class="img-fluid mx-auto d-block mg-md lazyload" alt="WordCount physical data-flow graphs" />
				<p class="text-justify">
														This example shows only a fraction of the expressive power of WindFlow, which is actually able to generate complex data-flow graphs using <strong>split</strong> and <strong>merge</strong> operations&nbsp;on MultiPipes. Interested users can refer to the doxygen documentation for the API and can look at the synthetic examples and tests distributed with the source code.
													</p>
			</div>
		</div>
	</div>
</div>
<!-- bloc-4 END -->

<!-- ScrollToTop Button -->
<a class="bloc-button btn btn-d scrollToTop" onclick="scrollToTarget('1',this)"><span class="fa fa-chevron-up"></span></a>
<!-- ScrollToTop Button END-->


<!-- bloc-8 -->
<div class="bloc l-bloc" id="bloc-8">
	<div class="container bloc-lg">
		<div class="row">
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					About
				</h4><a href="http://calvados.di.unipi.it/paragroup/" class="a-btn a-block footer-link ltc-azure">PPMs Group</a><a href="https://www.unipi.it/" class="a-btn a-block footer-link ltc-azure">University of Pisa</a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					<br>
				</h4><a href="index.html" class="a-btn a-block footer-link"></a><a href="index.html" class="a-btn a-block footer-link"><br></a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					<br>
				</h4><a href="index.html" class="a-btn a-block footer-link"><br></a><a href="index.html" class="a-btn a-block footer-link"></a>
			</div>
			<div class="col-md-3 col-sm-6">
				<h4 class="mg-md text-sm-left text-center">
					Get the library
				</h4><a href="https://github.com/ParaGroup/WindFlow/archive/refs/tags/3.6.0.zip" class="a-btn a-block footer-link ltc-azure">Download</a><a href="https://github.com/ParaGroup/WindFlow" class="a-btn a-block footer-link ltc-azure">GitHub</a>
			</div>
		</div>
	</div>
</div>
<!-- bloc-8 END -->

</div>
<!-- Main container END -->
    

<!-- Additional JS -->
<script src="./js/jquery-3.5.1.min.js?2031"></script>
<script src="./js/bootstrap.bundle.min.js?4164"></script>
<script src="./js/blocs.min.js?1456"></script>
<script src="./js/lazysizes.min.js" defer></script>
<script src="./js/prism.js?7440"></script>
<!-- Additional JS END -->


</body>
</html>
