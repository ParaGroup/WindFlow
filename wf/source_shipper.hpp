/******************************************************************************
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License version 3 as
 *  published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 *  License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 ******************************************************************************
 */

/** 
 *  @file    source_shipper.hpp
 *  @author  Gabriele Mencagli
 *  
 *  @brief Source_Shipper class used to send outputs generated by the Source operator
 *  
 *  @section Source_Shipper (Description)
 *  
 *  This file implements the Source_Shipper class used to send outputs generated by
 *  the Source operator.
 */ 

#ifndef SOURCE_SHIPPER_H
#define SOURCE_SHIPPER_H

/// includes
#include<ff/multinode.hpp>
#include<basic.hpp>
#include<single_t.hpp>
#if defined (WF_TRACING_ENABLED)
    #include<stats_record.hpp>
#endif
#include<basic_emitter.hpp>

namespace wf {

/** 
 *  \class Source_Shipper
 *  
 *  \brief Source_Shipper class used to send generated outputs by the Source operator
 *  
 *  This class implements the Source_Shipper class used to send outputs generated by
 *  the Source operator.
 */ 
template<typename result_t>
class Source_Shipper
{
private:
    template<typename T1> friend class Source_Replica; // friendship with the Source_Replica class
    Basic_Emitter *emitter; // pointer to the emitter used for the delivery of messages
    ff::ff_monode *node; // pointer to the fastflow node to be passed to the emitter
    Execution_Mode_t execution_mode; // execution mode of the Source_Shipper
    Time_Policy_t time_policy; // time mode of the Source_Shipper
    uint64_t num_delivered; // counter of the delivered results
    uint64_t max_timestamp; // maximum timestamp emitted by the source so far
    uint64_t watermark; // watermark to be used for sending the next output
    uint64_t initial_time_us = 0; // initial time in usec
#if defined (WF_TRACING_ENABLED)
    Stats_Record *stats_record = nullptr;
    double avg_ts_us = 0;
    double avg_td_us = 0;
    volatile uint64_t startTD, endTD;
#endif

    // Constructor
    Source_Shipper(Basic_Emitter *_emitter,
                   ff::ff_monode *_node,
                   Execution_Mode_t _execution_mode,
                   Time_Policy_t _time_policy):
                   emitter(_emitter),
                   node(_node),
                   execution_mode(_execution_mode),
                   time_policy(_time_policy),
                   num_delivered(0),
                   max_timestamp(0),
                   watermark(0) {}

    // Copy Constructor
    Source_Shipper(const Source_Shipper &_other):
                   node(_other.node),
                   execution_mode(_other.execution_mode),
                   time_policy(_other.time_policy),
                   num_delivered(_other.num_delivered),
                   max_timestamp(_other.max_timestamp),
                   watermark(_other.watermark)
    {
        if (_other.emitter != nullptr) {
            emitter = (_other.emitter)->clone();
        }
        else {
            emitter = nullptr;
        }
#if defined (WF_TRACING_ENABLED)
        stats_record = _other.stats_record;
#endif
    }

    // Move Constructor
    Source_Shipper(Source_Shipper &&_other):
                   emitter(std::exchange(_other.emitter, nullptr)),
                   node(std::exchange(_other.node, nullptr)),
                   execution_mode(_other.execution_mode),
                   time_policy(_other.time_policy),
                   num_delivered(_other.num_delivered),
                   max_timestamp(_other.max_timestamp),
                   watermark(_other.watermark)
    {
#if defined (WF_TRACING_ENABLED)
        stats_record = std::exchange(_other.stats_record, nullptr);
#endif
    }

    // Destructor
    ~Source_Shipper()
    {
        if (emitter != nullptr) {
            delete emitter;
        }
    }

    // Copy Assignment Operator
    Source_Shipper &operator=(const Source_Shipper &_other)
    {
        if (this != &_other) {
            if (emitter != nullptr) {
                delete emitter;
            }
            if (_other.emitter != nullptr) {
                emitter = (_other.emitter)->clone();
            }
            else {
                emitter = nullptr;
            }
            node = _other.node;
            execution_mode = _other.execution_mode;
            time_policy = _other.time_policy;
            num_delivered = _other.num_delivered;
            max_timestamp = _other.max_timestamp;
            watermark = _other.watermark;
#if defined (WF_TRACING_ENABLED)
            stats_record = _other.stats_record;
#endif
        }
        return *this;
    }

    // Move Assignment Operator
    Source_Shipper &operator=(Source_Shipper &&_other)
    {
        if (emitter != nullptr) {
            delete emitter;
        }
        emitter = std::exchange(_other.emitter, nullptr);
        node = std::exchange(_other.node, nullptr);
        execution_mode = _other.execution_mode;
        time_policy = _other.time_policy;
        num_delivered = _other.num_delivered;
        max_timestamp = _other.max_timestamp;
        watermark = _other.watermark;
#if defined (WF_TRACING_ENABLED)
        stats_record = std::exchange(_other.stats_record, nullptr);
#endif
        return *this;
    }

    // Set the initial time in usec
    void setInitialTime(uint64_t _initial_time_us)
    {
        initial_time_us = _initial_time_us;
    }

    // Set the execution and time mode of the Source_Shipper
    void setConfiguration(Execution_Mode_t _execution_mode,
                          Time_Policy_t _time_policy)
    {
        execution_mode = _execution_mode;
        time_policy = _time_policy;
    }

#if defined (WF_TRACING_ENABLED)
    // Set the pointer to the Stats_Record object
    void setStatsRecord(Stats_Record *_stats_record)
    {
        stats_record = _stats_record;
    }
#endif

public:
    /** 
     *  \brief Get the number of results delivered by the Source_Shipper
     *  
     *  \return number of results
     */ 
    uint64_t getNumDelivered() const
    {
        return num_delivered;
    }

    /** 
     *  \brief Deliver a result (with an implicit timestamp)
     *  
     *  \param _r result to be delivered (copy semantics)
     */ 
    void push(const result_t &_r)
    {
#if defined (WF_TRACING_ENABLED)
        if (stats_record->outputs_sent == 0) {
            startTD = current_time_nsecs();
        }
#endif
        if (time_policy != Time_Policy_t::INGRESS_TIME) { // push can be used with INGRESS_TIME only
            std::cerr << RED << "WindFlow Error: generation with implicit timestamps requires INGRESS_TIME policy" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        uint64_t timestamp = current_time_usecs() - initial_time_us; // calculate the timestamp
        max_timestamp = timestamp; // ingress_time timestamps are always monotonically increasing
        if (execution_mode == Execution_Mode_t::DEFAULT) {
            watermark = timestamp; // watermarks equal to timestamps in case of DEFAULT mode
        }
        result_t copy_result = _r; // copy the result to be delivered
#if defined (WF_TRACING_ENABLED)
        volatile uint64_t time_send = current_time_nsecs();
#endif
        emitter->emit(&copy_result, 0, timestamp, watermark, node);
        num_delivered++;
#if defined (WF_TRACING_ENABLED)
        stats_record->outputs_sent++;
        stats_record->bytes_sent += sizeof(result_t);
        endTD = current_time_nsecs();
        double elapsedtime_us = ((double) (endTD - startTD)) / 1000;
        double elapsedsend_us = ((double) (current_time_nsecs() - time_send)) / 1000;
        avg_ts_us += (1.0 / stats_record->outputs_sent) * ((elapsedtime_us - elapsedsend_us) - avg_ts_us);
        avg_td_us += (1.0 / stats_record->outputs_sent) * (elapsedtime_us - avg_td_us);
        stats_record->service_time = std::chrono::duration<double, std::micro>(avg_ts_us);
        stats_record->eff_service_time = std::chrono::duration<double, std::micro>(avg_td_us);
        startTD = current_time_nsecs();
#endif
    }

    /** 
     *  \brief Deliver a result (with an implicit timestamp)
     *  
     *  \param _r result to be delivered (move semantics)
     */ 
    void push(result_t &&_r)
    {
#if defined (WF_TRACING_ENABLED)
        if (stats_record->outputs_sent == 0) {
            startTD = current_time_nsecs();
        }
#endif
        if (time_policy != Time_Policy_t::INGRESS_TIME) { // push can be used with INGRESS_TIME only
            std::cerr << RED << "WindFlow Error: generation with implicit timestamps requires INGRESS_TIME policy" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        uint64_t timestamp = current_time_usecs() - initial_time_us; // calculate the timestamp
        max_timestamp = timestamp; // ingress_time timestamps are always monotonically increasing
        if (execution_mode == Execution_Mode_t::DEFAULT) {
            watermark = timestamp; // watermarks equal to timestamps in case of DEFAULT mode
        }
#if defined (WF_TRACING_ENABLED)
        volatile uint64_t time_send = current_time_nsecs();
#endif
        emitter->emit(&_r, 0, timestamp, watermark, node);
        num_delivered++;
#if defined (WF_TRACING_ENABLED)
        stats_record->outputs_sent++;
        stats_record->bytes_sent += sizeof(result_t);
        endTD = current_time_nsecs();
        double elapsedtime_us = ((double) (endTD - startTD)) / 1000;
        double elapsedsend_us = ((double) (current_time_nsecs() - time_send)) / 1000;
        avg_ts_us += (1.0 / stats_record->outputs_sent) * ((elapsedtime_us - elapsedsend_us) - avg_ts_us);
        avg_td_us += (1.0 / stats_record->outputs_sent) * (elapsedtime_us - avg_td_us);
        stats_record->service_time = std::chrono::duration<double, std::micro>(avg_ts_us);
        stats_record->eff_service_time = std::chrono::duration<double, std::micro>(avg_td_us);
        startTD = current_time_nsecs();
#endif
    }

    /** 
     *  \brief Deliver a result (with a user-defined timestamp)
     *  
     *  \param _r result to be delivered (copy semantics)
     *  \param _ts timestamp value (in microseconds starting from zero)
     */ 
    void pushWithTimestamp(const result_t &_r,
                           uint64_t _ts)
    {
#if defined (WF_TRACING_ENABLED)
        if (stats_record->outputs_sent == 0) {
            startTD = current_time_nsecs();
        }
#endif
        if (time_policy != Time_Policy_t::EVENT_TIME) { // pushWithTimestamp can be used with EVENT_TIME only
            std::cerr << RED << "WindFlow Error: generation with explicit timestamps requires EVENT_TIME policy" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        if (_ts >= max_timestamp) { // check if it is the maximum timestamp emitted so far
            max_timestamp = _ts;
        }
        else if (execution_mode == Execution_Mode_t::DETERMINISTIC) { // DETERMINISTIC mode requires monotonic timestamps
            std::cerr << RED << "WindFlow Error: user-defined timestamps must be monotonically increasing in DETERMINISTIC mode" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        result_t copy_result = _r; // copy the result to be delivered
#if defined (WF_TRACING_ENABLED)
        volatile uint64_t time_send = current_time_nsecs();
#endif
        emitter->emit(&copy_result, 0, _ts, watermark, node);
        num_delivered++;
#if defined (WF_TRACING_ENABLED)
        stats_record->outputs_sent++;
        stats_record->bytes_sent += sizeof(result_t);
        endTD = current_time_nsecs();
        double elapsedtime_us = ((double) (endTD - startTD)) / 1000;
        double elapsedsend_us = ((double) (current_time_nsecs() - time_send)) / 1000;
        avg_ts_us += (1.0 / stats_record->outputs_sent) * ((elapsedtime_us - elapsedsend_us) - avg_ts_us);
        avg_td_us += (1.0 / stats_record->outputs_sent) * (elapsedtime_us - avg_td_us);
        stats_record->service_time = std::chrono::duration<double, std::micro>(avg_ts_us);
        stats_record->eff_service_time = std::chrono::duration<double, std::micro>(avg_td_us);
        startTD = current_time_nsecs();
#endif
    }

    /** 
     *  \brief Deliver a result (with a user-defined timestamp)
     *  
     *  \param _r result to be delivered (move semantics)
     *  \param _ts timestamp value (in microseconds starting from zero)
     */ 
    void pushWithTimestamp(result_t &&_r,
                           uint64_t _ts)
    {
#if defined (WF_TRACING_ENABLED)
        if (stats_record->outputs_sent == 0) {
            startTD = current_time_nsecs();
        }
#endif
        if (time_policy != Time_Policy_t::EVENT_TIME) { // pushWithTimestamp can be used with EVENT_TIME only
            std::cerr << RED << "WindFlow Error: generation with explicit timestamps requires EVENT_TIME policy" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        if (_ts >= max_timestamp) { // check if it is the maximum timestamp emitted so far
            max_timestamp = _ts;
        }
        else if (execution_mode == Execution_Mode_t::DETERMINISTIC) { // DETERMINISTIC mode requires monotonic timestamps
            std::cerr << RED << "WindFlow Error: user-defined timestamps must be monotonically increasing in DETERMINISTIC mode" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
#if defined (WF_TRACING_ENABLED)
        volatile uint64_t time_send = current_time_nsecs();
#endif
        emitter->emit(&_r, 0, _ts, watermark, node);
        num_delivered++;
#if defined (WF_TRACING_ENABLED)
        stats_record->outputs_sent++;
        stats_record->bytes_sent += sizeof(result_t);
        endTD = current_time_nsecs();
        double elapsedtime_us = ((double) (endTD - startTD)) / 1000;
        double elapsedsend_us = ((double) (current_time_nsecs() - time_send)) / 1000;
        avg_ts_us += (1.0 / stats_record->outputs_sent) * ((elapsedtime_us - elapsedsend_us) - avg_ts_us);
        avg_td_us += (1.0 / stats_record->outputs_sent) * (elapsedtime_us - avg_td_us);
        stats_record->service_time = std::chrono::duration<double, std::micro>(avg_ts_us);
        stats_record->eff_service_time = std::chrono::duration<double, std::micro>(avg_td_us);
        startTD = current_time_nsecs();
#endif
    }

    /** 
     *  \brief Set the new watermark to be propagated with the next output
     *  
     *  \param _wm new watermark value (in microseconds starting from zero)
     */ 
    void configureWatermark(uint64_t _wm)
    {
        if (execution_mode != Execution_Mode_t::DEFAULT) { // check the execution mode of the PipeGraph
            std::cerr << RED << "WindFlow Error: watermarks can be set only in DEFAULT mode" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        if (_wm < watermark) { // check watermarks are monotonically increasing
            std::cerr << RED << "WindFlow Error: watermarks must be monotonically increasing" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        if (_wm > max_timestamp) { // current watermark cannot be greater than the emitted timestamp
            std::cerr << RED << "WindFlow Error: watermark cannot be greater than the highest emitted timestamp" << DEFAULT_COLOR << std::endl;
            exit(EXIT_FAILURE);
        }
        watermark = _wm;
    }

//@cond DOXY_IGNORE
    // Flushing function of the shipper
    void flush()
    {
        emitter->flush(node); // call the flush of the emitter
    }
//@endcond
};

} // namespace wf

#endif
